1. 기본 개념 (Foreground vs Background)

Foreground (포그라운드)
* 터미널에 컨테이너의 실행 로그가 직접 출력되며, 해당 터미널이 컨테이너의 프로세스에 묶여 조작이 불가능한 상태
    (Ctrl + C를 누르면 컨테이너가 종료)

Background (백그라운드 / Detached Mode)
* 컨테이너가 컴퓨터(서버)의 백그라운드 프로세스로 실행
* 터미널에 로그가 보이지 않으며, 즉시 터미널 조작이 가능
* 주로 서버 배포 시 사용하며 -d 옵션을 사용


2. 이미지 관리 (Image) 
* 이미지 = 컨테이너 생성을 위한 설계도

    docker search [검색어] : Docker Hub에서 이미지 검색

    docker pull [이미지명] : 이미지 다운로드 (태그 생략 시 자동으로 latest 다운)
    docker pull [이미지명]:[태그] : 특정 버전의 이미지 다운로드 (예: python:3.9)

    docker image ls (또는 docker images) : 다운로드된 이미지 목록 조회
    docker image rm [이미지 ID/이름] : 이미지 삭제
    docker image rm -f [이미지 ID/이름] : 이미지 강제 삭제 (사용 중인 컨테이너가 있어도 삭제 시도)
    docker image prune : 이름이 없는(Dangling) 불필요한 이미지 일괄 삭제

    * 전체 삭제 명령어
    docker image rm $(docker images -q) : 사용 중이지 않은 모든 이미지 삭제
    docker image rm -f $(docker images -q) : 모든 이미지 강제 삭제 (주의 요망)


3. 컨테이너 생성 및 실행 (Run)
* docker run = docker pull + create + start (단계 합쳐놓음)

* 기본 명령어
    docker run [이미지] : 이미지를 기반으로 컨테이너 생성 및 실행 (기본: Foreground)
    docker create [이미지] : 컨테이너를 생성만 하고 실행은 하지 않음 (run과 명령어, 옵션 사용 거의 동일)

* 자주 쓰는 docker run 옵션
    -d : 백그라운드 모드로 실행 (Detached)
    -p [호스트포트]:[컨테이너포트] : 포트 포워딩 (예: -p 80:8080 $\rightarrow$ 내 컴퓨터 80번으로 접속하면 컨테이너 8080으로 연결)
    --name [이름] : 컨테이너에 식별하기 쉬운 이름 부여
    -e [변수명]=[값] : 환경변수 설정 (예: DB 비밀번호 등 설정 시 사용)
    -v [호스트경로]:[컨테이너경로] : 볼륨 마운트 (내 컴퓨터의 파일을 컨테이너와 공유/저장)
    --rm : 컨테이너 종료 시 자동으로 삭제 (일회성 테스트에 유용)
    -it : 터미널 입력을 위한 옵션 (-i와 -t를 합쳐서 주로 사용)

* (예시)
    docker run -d -p 8080:80 --name my-web-server nginx# nginx 
    * 이미지를 백그라운드에서, 내 컴퓨터 8080포트로 연결하고, 이름은 my-web-server로 실행


4. 컨테이너 조회 및 로그 (Monitoring)

* 실행 중인 컨테이너 상태를 확인
    docker ps : 현재 실행 중인 컨테이너 목록 조회
    docker ps -a : 종료된 것을 포함한 모든 컨테이너 목록 조회

    docker logs [컨테이너 ID/이름] : 컨테이너의 로그 전체 출력
    docker logs --tail [숫자] [컨테이너] : 마지막 [숫자] 줄 만큼의 로그만 출력
    docker logs -f [컨테이너] : 로그를 실시간으로 계속 추적하여 출력 (실무에서 디버깅 시 필수)


5. 컨테이너 제어 및 접속 (Control & Exec)

* 이미 실행된 컨테이너를 멈추거나, 실행 중인 컨테이너 안에 들어가서 명령어를 칠 때 사용

docker stop [컨테이너] : 컨테이너를 정상적으로 종료 (하던 작업 마무리 후 종료)
docker kill [컨테이너] : 컨테이너를 즉시 강제 종료 (전원 끄듯 바로 끊음)
docker start [컨테이너] : 종료된 컨테이너를 다시 실행 (기본: Background)
docker restart [컨테이너] : 재부팅 (Stop $\rightarrow$ Start)
docker exec -it [컨테이너] /bin/bash : (중요) 실행 중인 컨테이너의 내부 쉘(터미널)로 접속


6. 컨테이너 삭제 (Delete)

docker rm [컨테이너] : 종료된 컨테이너 삭제 (실행 중이면 에러)
docker rm -f [컨테이너] : 실행 중인 컨테이너 강제 삭제 (kill 후 rm 하는 효과)
docker container prune : 종료된(Stopped) 모든 컨테이너 일괄 삭제

* 전체 삭제 명령어
    docker rm $(docker ps -qa) : 모든 컨테이너 ID를 가져와서 삭제 (실행 중인 것은 실패할 수 있음)
    docker stop $(docker ps -q) && docker rm $(docker ps -qa) : 실행 중인 모든 것을 멈추고 싹 다 삭제


7. (추가) 시스템 청소 (System Prune)

docker system prune -a : 사용하지 않는 모든 데이터(중지된 컨테이너, 안 쓰는 네트워크, 댕글링 이미지 등)를 삭제합니다. 
(매우 강력)


요약: 워크플로우 순서
    1. docker pull (이미지 준비)
    2. docker run -d --name ... (옵션 넣어 실행)
    3. docker ps (잘 떴는지 확인)
    4. docker logs -f (에러 없는지 로그 확인)
    5. docker exec -it (필요시 내부 들어가서 설정 확인)
    6. docker stop $\rightarrow$ docker rm (사용 후 정리)

(추가) 도커에서 mysql 실행
docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=1234 -v ~/Desktop/docker-mysql/mysql-data:/var/lib/mysql mysql
(-e는 환경변수 설정 -> 패스워드 설정, -v는 도커 볼륨 설정 -> 로컬 저장소 경로:mysql 경로)
*실행 시 로컬 저장소 경로에 있는 파일을 mysql로 복사 덮어쓰기 해버림.
* 로컬 저장소에 비밀번호가 설정되어 저장되어 있다면, 나중에 다른 비밀번호를 입력해 명령어를 실행시키더라도 적용되지 않음.